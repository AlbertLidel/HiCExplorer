#!/usr/bin/env python
#-*- coding: utf-8 -*-

import argparse, sys
import numpy as np

import matplotlib
matplotlib.use('Agg')
import matplotlib.pyplot as plt
import matplotlib.gridspec as gridspec
import matplotlib.cm as cm
import hicexplorer.HiCMatrix as hm
import hicexplorer.utilities
import logging
log = logging.getLogger(__name__)


def parseArguments(args=None):
    parser = argparse.ArgumentParser(description = 'Takes a list of positions '
                                     'in the hic-matrix and makes a pooled image.')

    # define the arguments
    parser.add_argument('--matrix', '-m',
                        help='Path of the Hi-C matrix to plot.',
                        required=True)

    parser.add_argument('--BED',
                        help='Interactions between regions in this BED file are plotted.',
                        type=argparse.FileType('r'),
                        required=True)

    parser.add_argument('--BED2',
                        help='Optional second BED file. Interactions between regions in first '
                             'and second BED file are plotted.',
                        type=argparse.FileType('r'),
                        required=False)

    parser.add_argument('--range',
                        help='Range of contacts that will be considered for plotting the aggregate contacts '
                            'in bp with the format low_range:high_range for example 1000000:20000000.'
                            'The range should start at contacts larger than TAD size to reduce background interactions.',
                        required=True)

    parser.add_argument('--numberOfBins',
                        help='Number of  bins to include in the submatrix. The bed regions will be centered between '
                             '- half number of bins and the other half number of bins.',
                        default='51',
                        type=int)

    parser.add_argument('--transform',
                        help='Type of transformation for the matrix. The options are "none",  '
                             '"total-counts", "z-score" or "obs/exp". If total counts are selected, '
                             'then the sub-matrix values are divided by the total counts for normalization. '
                             'If z-score or obs/exp are selected, then H-C matrix is converted into a '
                             'z-score or observed / expected matrix.',
                        choices=['total-counts', 'z-score', 'obs/exp', 'none'],
                        default='none')

    parser.add_argument('--avgType',
                        help='Type of average to compute final matrix. Options are mean and median. Default is median.',
                        choices=['mean', 'median'],
                        default='median')

    parser.add_argument('--outFileName', '-out',
                        help='File name to save the image. ',
                        type=argparse.FileType('w'),
                        required=True)
    
    parser.add_argument('--outFilePrefixMatrix',
                        help='If this option is given, then the values underlying the final matrix will be '
                             'saved to tab-delimited tables (one per chromosome) using the indicated prefix, '
                             'for example TSS_to_TSS_chrX.tab',
                        type=argparse.FileType('w'),
                        required=False)

    parser.add_argument('--diagnosticHeatmapFile',
                        help='If given, a heatmap file (per chromosome) is saved. Each row in the heatmap contains the'
                             'diagonal of each of the submatrices centered on the bed file. This file is useful to '
                             'get an idea of the values that are used for the aggregate matrix and to determine '
                             'the fraction of sub-matrices that are aggregated that may have an enrichment at the '
                             'center.',
                        type=argparse.FileType('w'),
                        required=False)

    parser.add_argument('--kmeans',
                        help='Number of clusters to compute. When this '
                             'option is set, the submatrices are split into clusters (per chromosome)'
                             'using the k-means algorithm.',
                        type=int)

    parser.add_argument('--hclust',
                        help='Number of clusters to compute (per chromosome). When this '
                             'option is set, then the matrix is split into clusters '
                             'using the hierarchical clustering algorithm, using "ward linkage". '
                             ' --hclust could be very slow if you have '
                             '>1000 submatrices per chromosome. In those cases, you might prefer --kmeans',
                        type=int)

    parser.add_argument('--clusterOnDiagonal',
                        help='Clustering is by default carried out on the whole submatrices. If this parameter '
                             'is given, the clustering is only carried out based on the submatrix diagonal '
                             '(representing values at the same distance to each other)',
                        action='store_true')

    parser.add_argument('--chromosomes', '-C',
                        help='List of chromosomes to plot.',
                        nargs='+')

    parser.add_argument('--colorMap',
                        help='Color map to use for the heatmap. Available '
                        'values can be seen here: '
                        'http://matplotlib.org/examples/color/colormaps_reference.html',
                        default='RdYlBu_r')

    parser.add_argument('--plotType',
                        help='Plot type.',
                        choices=['2d', '3d'],
                        default='2d')

    parser.add_argument('--vMin',
                        help='vMin',
                        type=float,
                        default=None)

    parser.add_argument('--vMax',
                        help='vMax',
                        type=float,
                        default=None)

    return parser.parse_args(args)


def read_bed_per_chrom(fh):
    """
    Reads the given BED file returning
    a dictionary that contains, per each chromosome
    a list of start, end
    """
    interval = {}
    for line in fh:
        if line[0] == "#":
            continue
        fields = line.strip().split()
        if fields[0] not in interval:
            interval[fields[0]] = []

        interval[fields[0]].append((int(fields[1]), int(fields[2])))

    return interval


def cluster_matrices(submatrices_dict, k, method='kmeans', use_diagonal=False):
    """
    clusters the submatrices per chromosome


    Parameters
    ----------
    submatrices_dict key: chrom name, values, a list of submatrices
    k number of clusters
    method either kmeans or hierarchical
    use_diagonal instead of using the whole submatrix for clustering, use only the diagonal.

    Returns
    -------

    indices dict key: chrom_name, value: list of list, with one list per cluster with the ids of the submatrices
                 that belong to that list
    """

    clustered_dict = {}
    for chrom in submatrices_dict:
        submat_vectors = []
        shape = submatrices_dict[chrom][0].shape
        for submatrix in submatrices_dict[chrom]:
            if use_diagonal:
                # take from each matrix the diagonal
                submat_vectors.append(submatrix.diagonal())
            else:
                # Transform list of submatrices in an array of shape:
                # shape = (num_submatrices, submatrix.shape[0] * submatrix.shape[1]
                # In other words, each submatrix is converted into a row of the matrix
                submat_vectors.append(submatrix.reshape((1, shape[0] * shape[1])))

        matrix = np.vstack(submat_vectors)
        if use_diagonal:
            assert matrix.shape == (len(submatrices_dict[chrom]), shape[0])
        else:
            assert matrix.shape == (len(submatrices_dict[chrom]), shape[0] * shape[1])

        if np.any(np.isnan(matrix)):
            # replace nans for 0 otherwise kmeans produces a weird behaviour
            sys.stderr.write("*Warning* For clustering nan values have to be replaced by zeros \n")
            matrix[np.isnan(matrix)] = 0

        if method == 'kmeans':
            from scipy.cluster.vq import vq, kmeans

            centroids, _ = kmeans(matrix, k)
            # order the centroids in an attempt to
            # get the same cluster order
            cluster_labels, _ = vq(matrix, centroids)

        if method == 'hierarchical':
            # normally too slow for large data sets
            from scipy.cluster.hierarchy import fcluster, linkage
            Z = linkage(matrix, method='ward', metric='euclidean')
            cluster_labels = fcluster(Z, k, criterion='maxclust')
            # hierarchical clustering labels from 1 .. k
            # while k-means labels 0 .. k -1
            # Thus, for consistency, we subtract 1
            cluster_labels -= 1

        # sort clusters
        clustered_dict[chrom] = []
        for cluster in range(k):
            cluster_ids = np.flatnonzero(cluster_labels == cluster)
            clustered_dict[chrom].append(cluster_ids)

    return clustered_dict


def main(args):
    ma = hm.hiCMatrix(args.matrix)
    ma.maskBins(ma.nan_bins)
    ma.matrix.data[np.isnan(ma.matrix.data)] = 0

    bin_size = ma.getBinSize()
    ma.maskBins(ma.nan_bins)
    ma.matrix.data = ma.matrix.data
    new_intervals = hicexplorer.utilities.enlarge_bins(ma.cut_intervals)
    ma.setCutIntervals(new_intervals)
    min_dist, max_dist = args.range.split(":")

    if args.chromosomes:
        ma.keepOnlyTheseChr(args.chromosomes)
    chrom_list = ma.chrBinBoundaries.keys()
    log.info("checking range {}-{}".format(min_dist, max_dist))
    min_dist = int(min_dist)
    max_dist = int(max_dist)
    assert min_dist < max_dist, "Error lower range larger than upper range"

    if args.transform == "z-score":
        # use zscore matrix
        log.info("Computing z-score matrix. This may take a while.\n")
        ma.convert_to_zscore_matrix(maxdepth=max_dist * 2.5, perchr=True)
    elif args.transform == "obs/exp":
        # use zscore matrix
        log.info("Computing observed vs. expected matrix. This may take a while.\n")
        ma.convert_to_obs_exp_matrix(maxdepth=max_dist * 2.5, perchr=True)

    min_dist_in_bins = int(min_dist) / bin_size
    max_dist_in_bins = int(max_dist) / bin_size

    # read and sort bedgraph.
    bed_intervals = read_bed_per_chrom(args.BED)
    if args.BED2:
        bed_intervals2 = read_bed_per_chrom(args.BED2)
    else:
        bed_intervals2 = bed_intervals

    M = args.numberOfBins if args.numberOfBins % 2 == 1 else args.numberOfBins + 1
    M_half = int((M - 1) / 2)
    # make a new matrix for each chromosome.
    chrom_matrix = {}
    chrom_total = {}
    chrom_diagonals = {}
    seen = {}

    center_values = []
    for chrom in chrom_list:
        chrom_matrix[chrom] = []
        chrom_total[chrom] = 1
        chrom_diagonals[chrom] = []
        seen[chrom] = set()
        over_1_5 = 0
        chrom_bin_range = ma.getChrBinRange(chrom)

        sys.stderr.write(chrom + '\n')
        # if chrom == '2R':
        #     import ipdb; ipdb.set_trace()
        if chrom not in bed_intervals:
            continue
        for start, end in bed_intervals[chrom]:
            # check all other regions that may interact with the
            # current interval at the given depth range

            bin_id = ma.getRegionBinRange(chrom, start, end)
            if bin_id is None:
                continue
            else:
                bin_id = bin_id[0]

            for start2, end2 in bed_intervals2[chrom]:
                bin_id2 = ma.getRegionBinRange(chrom, start2, end2)
                if bin_id2 is None:
                    continue
                else:
                    bin_id2 = bin_id2[0]
                if bin_id2 in seen[chrom]:
                    continue
                if min_dist_in_bins <= abs(bin_id2 - bin_id) <= max_dist_in_bins:
                    idx1, idx2 = sorted([bin_id, bin_id2])
                    if (idx1, idx2) in seen[chrom]:
                        continue
                    seen[chrom].add((idx1, idx2))
                    if idx1 - M_half < chrom_bin_range[0] or \
                            idx2 + 1 + M_half > chrom_bin_range[1]:
                        continue
                    try:
                        mat_to_append = ma.matrix[idx1 - M_half:idx1 + M_half + 1, :][:, idx2 - M_half:idx2 + M_half + 1].todense().astype(float)
                    except IndexError:
                        sys.stderr.write("index error for {} {}\n".format(idx1, idx2))
                        continue
                    if mat_to_append.sum() <= 0:
                        sys.stderr.write("empty matrix for positions {} {}\n".format(idx1, idx2))
                        continue
                    # to account for the fact that submatrices
                    # close to the diagonal have more counts thatn
                    # submatrices far from the diagonal
                    # the submatrices values are normalized using the
                    # total submatrix sum.
#
                    if args.transform == 'total_counts' and mat_to_append.sum() > 0:
                        mat_to_append = mat_to_append / mat_to_append.sum()

                    chrom_total[chrom] += 1
                    chrom_matrix[chrom].append(mat_to_append)
                    chrom_diagonals[chrom].append(mat_to_append.diagonal())
                    center_values.append(ma.matrix[idx1, idx2])
                    if ma.matrix[idx1, idx2] > 1.5:
                        log.info("Enrichment at center for positions {}:{}-{}, {}:{}-{}".format(chrom, start, end,
                                                                                                chrom, start2, end2))
                        over_1_5 += 1
        log.info("Number of matrices with ratio over 1.5 at center {} ({:.2f})".
                 format(over_1_5, float(over_1_5) / len(chrom_matrix)))

    num_cols = len(chrom_matrix)
    num_rows = 1

    if args.kmeans is not None:
        cluster_ids = cluster_matrices(chrom_matrix, args.kmeans, method='kmeans', use_diagonal=args.clusterOnDiagonal)
        num_rows = args.kmeans
    elif args.hclust is not None:
        log.info("Performing hierarchical clustering."
                 "Please note that it might be very slow for large datasets.\n")
        cluster_ids = cluster_matrices(chrom_matrix, args.hclust, method='hierarchical', use_diagonal=args.clusterOnDiagonal)
        num_rows = args.hclust
    else:
        # make a 'fake' clustering to generalize the plotting of the submatrices
        cluster_ids = {}
        for chrom in chrom_list:
            cluster_ids[chrom] = [range(len(chrom_list[chrom]))]

    fig = plt.figure(figsize=(8 * num_cols, 5.5 * num_rows))
    gs = gridspec.GridSpec(num_rows, num_cols + 1,
                           width_ratios=[10] * len(chrom_matrix) + [0.6],
                           height_ratios=[10] * num_rows)

    gs.update(wspace=0.01, hspace=0.2)
    chrom_avg = {}
    chrom_cluster_len = {}
    for idx, chrom in enumerate(chrom_list):
        chrom_avg[chrom] = []
        chrom_cluster_len[chrom] = []
        for cluster_number, cluster_indices in enumerate(cluster_ids[chrom]):
            # compute median values
            if num_rows == 1:
                # this means no clustering
                submatrices = np.array(chrom_matrix[chrom])
            else:
                submatrices = np.array([chrom_matrix[chrom][x] for x in cluster_indices])

            chrom_cluster_len[chrom].append(len(cluster_ids))

            if args.avgType == 'median':
                _median = np.median(submatrices, axis=0)
                if _median.sum() == 0 or np.isnan(_median.sum()):
                    # test if the mean matrix is not zero
                    if np.mean(submatrices, axis=0).sum() != 0:
                        sys.stderr.write("The median of the matrices is zero. Consider using "
                                         "the mean instead.\n\n")
                    else:
                        sys.stderr.write("Apparently no matrices could be computed. All are "
                                         "zeros or nans.\n\n")
                chrom_avg[chrom].append(_median)
            else:
                chrom_avg[chrom].append(np.mean(submatrices, axis=0))

            log.info("Mean aggregate matrix values: {}".format(chrom_avg[chrom][cluster_number].mean()))

    vmin, vmax = (args.vMin, args.vMax)
    cmap = cm.get_cmap(args.colorMap)

    log.debug("vmax: {}, vmin: {}".format(vmax, vmin))
    for idx, chrom in enumerate(chrom_list):
        for cluster_number, cluster_indices in enumerate(cluster_ids[chrom]):
            log.info("total pairs considered for {}, cluster_{}: {}".format(chrom, cluster_number + 1,
                                                                            len(cluster_indices)))
            try:
                chrom_avg[chrom][cluster_number].shape[0]
            except IndexError:
                continue
            if chrom_avg[chrom][cluster_number].shape[0] == 0:
                log.info("matrix for chrom {} is empty".format(chrom))
                continue
            if num_rows == 1:
                title = chrom
            else:
                title = "{} cluster_{}".format(chrom, cluster_number + 1)
            if args.plotType == '2d':
                ax = plt.subplot(gs[cluster_number, idx])

                ax.set_title(title)
                img = ax.imshow(chrom_avg[chrom][cluster_number], aspect='equal',
                                interpolation='nearest', vmax=vmax, vmin=vmin,
                                cmap=cmap,
                                extent=[-M_half, M_half + 1, -M_half, M_half + 1])
            else:
                from mpl_toolkits.mplot3d import Axes3D
                ax = Axes3D(fig)
                ax.set_aspect('equal')
                ax.margins(0)
                X, Y = np.meshgrid(range(-M_half, M_half + 1),
                                   range(-M_half, M_half + 1))
                Z = chrom_avg[chrom][cluster_number].copy()

                img = ax.plot_surface(X, Y, Z, rstride=1, cstride=1, linewidth=0, cmap=cmap,
                                      vmax=vmax, vmin=vmin, edgecolor='none')

                ax.set_zticklabels([])
                if vmax is not None and vmax is not None:
                    ax.set_zlim(vmin, vmax)

            if args.outFilePrefixMatrix:
                if num_rows == 1:
                    output_matrix_name="{file}_{chrom}.tab".format(file=args.outFilePrefixMatrix.name, chrom=chrom)
                else:
                    output_matrix_name="{file}_{chrom}_cluster_{id}.tab".format(file=args.outFilePrefixMatrix.name,
                                                                              chrom=chrom,id=cluster_number )
                np.savetxt(output_matrix_name, chrom_avg[chrom][cluster_number], '%0.5f', delimiter='\t')

    cbar_x = plt.subplot(gs[1,-1])
    fig.colorbar(img, cax=cbar_x)
    plt.savefig(args.outFileName.name, dpi=100, transparent=True)
    plt.close()
    
    # plot the diagonals
    # the diagonals plot is useful to see individual cases and if they had a contact in the center
    if args.diagnosticHeatmapFile:
        vmax_heat = vmax
        if vmax_heat is not None:
            vmax_heat *=  5

        vmin_heat = vmin
        if vmin_heat is not None:
            vmin_heat *=  5

        num_plots = len(chrom_diagonals)
        fig = plt.figure(figsize=(num_plots * 4, 20))

        gs0 = gridspec.GridSpec(2, num_plots + 1, width_ratios=[10] * num_plots + [0.5], height_ratios=[1, 5],
                                wspace=0.1, hspace=0.08)

        gs_list = []
        for idx, (chrom_name, values) in enumerate(chrom_diagonals.iteritems()):
            try:
                heatmap = np.asarray(np.vstack(values))
            except ValueError:
                continue

            # get size of each cluster for the given chrom
            clust_len = [(len(v)) for v in cluster_ids[chrom]]

            # prepare layout
            gs_list.append(gridspec.GridSpecFromSubplotSpec(len(clust_len), 1,
                                                            subplot_spec=gs0[1, idx],
                                                            height_ratios=clust_len,
                                                            hspace=0.01))
            summary_plot_ax = plt.subplot(gs0[0, idx])

            for cluster_number, cluster_indices in enumerate(cluster_ids[chrom]):
                # sort by the value at the center of the rows
                heatmap_to_plot = heatmap[cluster_indices, :]

                order = np.argsort(heatmap_to_plot[:, M_half])[::-1]
                heatmap_to_plot = heatmap_to_plot[order, :]

                # add line to summary plot ax
                y_values = heatmap_to_plot.mean(axis=0)
                x_values = np.arange(len(y_values) - M_half)
                summary_plot_ax.plot(x_values, y_values)

                ax = plt.subplot(gs_list[-1][cluster_number, 0])
                ax.set_yticks([])
                if cluster_number == 0:
                    ax.set_title(chrom_name)
                if num_rows > 1:
                    ax.set_ylabel("cluster_{}".format(cluster_number + 1))

                if cluster_number < num_rows - 1:
                    ax.set_xticks([])

                heat_fig = ax.imshow(heatmap_to_plot, aspect='auto',
                                     interpolation='nearest',
                                     cmap=cmap,
                                     origin='upper', vmax=vmax_heat, vmin=vmin_heat,
                                     extent=[-M_half, M_half + 1,
                                             0, len(order)])

        cbar_x = plt.subplot(gs0[1,-1])
        fig.colorbar(heat_fig, cax=cbar_x, orientation='vertical')

        file_name = args.diagnosticHeatmapFile.name
        log.info('Heatmap file saved under: {}'.format(file_name))
        plt.savefig(file_name, dpi=200)


if __name__ == "__main__":
    args = parseArguments()
    main(args)
